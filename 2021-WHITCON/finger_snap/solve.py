#!/usr/bin/python3
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from itertools import product
from queue import Queue


def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    g, y, x = egcd(b % a, a)
    return (g, x - (b//a) * y, y)


def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('No modular inverse')
    return x % m


n = int('1010011010100100011111100110101101110010100010111000010000000011110001111100000001011000101100110000001100111111100100001100010101001011101100010010000111001110011010010000110101000001010100101101100000001000001001011000011000110010111001100010010110100110110010101001001001000111001011010010000110011001100100010011010110010101001100000101110110010110111000001011101100101100111000111000100101100100100100010110100010010100100001111110011011011100001001110000101111111100101111100000111110110111110011000011011000100001110001111111101000010011010110111000000011101010000000110111101100000010110111111101001011101010111101100110101111010111001110110000101111100011110001001111000001101001011010011001001011101101000100001100001010111011011111100010110111100011110111100001011010011110000100001100010001101010110111101010011111101001100100010000101001110101110111001011011111011001000110101110010111111111100001000010110100110001100100010011110111001101011000111000100100111110111000101010101101011111011001110000110010100001', 2)

p = '110?01????0010??1?10??01???010?01???01?101100???1111??1??010????0?0?1????1?0001??00?11???111?001??0?010?1??00??01?1001??0??0??1??0?00?010?01000111010?11?1??1?011010110111?00?0?0???10?1?100????0100????1110???1????1????1?0??01???001001?00????10?0???110??101?1111??00??1?10?11?01?0100?11??100001010??1??111????1????0??010?11??00?0?0??11110?1?0????000?101?1?001??0111?0?1???01???01?0?1000?100???1??0?0?01?100110?0??0??01?000?11?1?0100??00?0????101?0?1?????00??10?0000??10??1?01??0000?1?110??01010?00???0?????0?1??111'
q = '1100??100??0000???1?00?0??101????10?11?01??1010?110?1?0?01?0?000?0?1?1111??111?1101?1?101?????100??10??0??010??1??1?100??1?110??1??1?101?1??10?00?0??1?11110?1?1??0?0?00????10??10?110?0111?0??1?0111??0?????1?11???????01??111????0??001??1??110??0?00????0?01???11?110101?0000?1010010110???1110100???01111?0??00????0110?1110??0???100?1?001?00110001?01??0?10??11??0?1?0?1?1?1?0101101?0?11010101?1??1?0010000??0?1??00????0??1?0?111??110??001???????1?0?11??011?0?????0??110?0???10???000???0?0100??011?1???01?01?0??111?1'

enc_flag = bytes([0xA0, 0x27, 0x25, 0x92, 0xBA, 0x14, 0x9B, 0xE8, 0xC4, 0xC7, 0x7D, 0x0E, 0xD1, 0xB1, 0xC3, 0x9B, 0x2E, 0xEB, 0x7A, 0xB2, 0x0B, 0x98, 0x37, 0x65, 0xD3, 0x92, 0x46, 0xDB, 0x4E, 0x0D, 0xFC, 0x09, 0xDA, 0x99, 0x04, 0xA6, 0x73, 0x51, 0xD8, 0x93, 0xAD, 0x06, 0x6F, 0x06, 0xF8, 0x96, 0x56, 0x61, 0xD3, 0xED, 0x0C, 0xDB, 0x25, 0xA9, 0x05, 0x87, 0xFD, 0x20, 0xAE, 0x1D, 0xB7, 0xF8, 0x23, 0x96, 0xAD, 0x01, 0x34, 0xA1, 0x4E, 0x86, 0x65, 0x94, 0x28, 0xD5, 0x05, 0xE8, 0x59, 0x65, 0x49, 0x8F, 0x6A, 0x20, 0xAE, 0xCF, 0xD9, 0xBD, 0x13, 0x03, 0x58, 0xA5, 0xA2, 0x0B, 0x12, 0x6A, 0x22, 0xEF, 0x51, 0xD3, 0x69, 0x5D, 0x67, 0x08, 0xCD, 0xCD, 0x56, 0xA8, 0x20, 0xEF, 0x06, 0x1D, 0xCB, 0xE7, 0x8D, 0xB8, 0x6B, 0xD6, 0x10, 0x53, 0x29, 0x3B, 0xCB, 0xC2, 0xAB, 0x7E, 0xE2, 0xD0, 0x43, 0x39])

queue = Queue()
queue.put((int(p[-1]), int(q[-1]), 1))

while not queue.empty():
    partial_p, partial_q, i = queue.get()
    if partial_p * partial_q == n:
        break

    nexti = i + 1
    mask = (1 << nexti) - 1

    if p[512 - nexti] == '?':
        ps = [partial_p, (1 << i) + partial_p]
    else:
        ps = [(int(p[512 - nexti]) << i) + partial_p]

    if q[512 - nexti] == '?':
        qs = [partial_q, (1 << i) + partial_q]
    else:
        qs = [(int(q[512 - nexti]) << i) + partial_q]

    for tp, tq in product(ps, qs):
        if (tp * tq) & mask == n & mask:
            queue.put((tp, tq, nexti))

p, q = partial_p, partial_q
assert p * q == n

e = 0x10001
d = modinv(e, (p - 1) * (q - 1))

rsa = RSA.construct((n, e, d, p, q))
cipher = PKCS1_OAEP.new(rsa)

flag = cipher.decrypt(enc_flag).decode()
print(flag)
